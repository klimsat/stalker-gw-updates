-- =======================================================================================
-- Remade by Tronex
-- Last modification: 2018/7/17
-- New Game menu + Ironman mode save killer + Setting up new games
-- =======================================================================================

--=======================================< Controls >=======================================--
local PORTRAITS_COUNT = 100
local ico_size = 0.7
local ico_width = (device().width / device().height > (1024 / 768 + 0.01)) and 0.8 or 1
local ini = system_ini()
local ini_ico = ini_file("plugins\\player_icons.ltx")
local ini_itm = ini_file("plugins\\new_game_loadouts.ltx")
local ini_map = ini_file("plugins\\new_game_start_locations\\default.ltx")
local ini_opt = ini_file("plugins\\new_game_options.ltx")
-->>local ini_eco = ini_file("misc\\economy_difficulty.ltx")
local gs = GetString

--=======================================< Callbacks >=======================================--
local start_pos
local function on_game_load(binder)
  local config = axr_main.config
  if not (config) then
    return
  end

  local se_actor = alife():actor()
  local need_save

  -- Gameplay Options
  if (USE_MARSHAL) then
    if (config:r_value("character_creation", "new_game_hardcore_mode", 1) == true) then
      -- shitty way to make a uuid but should be good enough to track the same saves
      alife_storage_manager.get_state().uuid =
        GAME_VERSION .. "_" .. tostring(math.random(100)) .. tostring(math.random()) .. tostring(math.random(1000))
      alife_storage_manager.get_state().death_limit =
        config:r_value("character_creation", "new_game_hardcore_mode_lives", 2) or 1
      alife_storage_manager.get_state().ironman_life_cycle =
        config:r_value("character_creation", "new_game_hardcore_mode_regenerate", 2)
      alife_storage_manager.get_state().ironman_life_feature =
        config:r_value("character_creation", "new_game_hardcore_mode_regenerate", 2) and true or nil
      config:w_value("character_creation", "new_game_hardcore_mode")
      config:w_value("character_creation", "new_game_hardcore_mode_lives")
      config:w_value("character_creation", "new_game_hardcore_mode_regenerate")
      need_save = true
    end
    if (config:r_value("character_creation", "new_game_survival_mode", 1) == true) then
      alife_storage_manager.get_state().enable_survival_mode = true
      config:w_value("character_creation", "new_game_survival_mode")
      need_save = true
    end
    if (config:r_value("character_creation", "new_game_campfire_mode", 1) == true) then
      alife_storage_manager.get_state().enable_campfire_mode = true
      config:w_value("character_creation", "new_game_campfire_mode")
      need_save = true
    end
    if (config:r_value("character_creation", "new_game_conditions_mode", 1) == true) then
      alife_storage_manager.get_state().enable_conditions_mode = true
      config:w_value("character_creation", "new_game_conditions_mode")
      need_save = true
    end
    if (config:r_value("character_creation", "new_game_timer_mode", 2)) then
      alife_storage_manager.get_state().enable_timer_mode =
        config:r_value("character_creation", "new_game_timer_mode", 2)
      config:w_value("character_creation", "new_game_timer_mode")
      need_save = true
    end

    if (config:r_value("character_creation", "new_game_difficulty", 0, "stalker")) then
      local diff = config:r_value("character_creation", "new_game_difficulty", 0, "stalker")
      local console = get_console()
      console:execute("g_game_difficulty gd_" .. diff)
      config:w_value("character_creation", "new_game_difficulty")
      need_save = true
    end
  end

  local azazelEnabled = config:r_value("character_creation", "new_game_azazel_mode", 1, false)
  if azazelEnabled then
    config:w_value("character_creation", "new_game_azazel_mode")
    azazel_mode.enabled = azazelEnabled
    need_save = true
  end

  -- Name
  local new_character_name = config:r_value("character_creation", "new_game_character_name", 0, "")
  if (new_character_name and new_character_name ~= "") then
    config:w_value("character_creation", "new_game_character_name")

    need_save = true

    new_character_name = new_character_name:gsub("_", " ")
    sim_brain.actor_name = new_character_name
    se_actor:set_character_name(new_character_name)
  end
  -- Name
  local new_character_name = config:r_value("character_creation", "new_game_character_name", 0, "")
  if (new_character_name and new_character_name ~= "") then
    config:w_value("character_creation", "new_game_character_name")

    need_save = true

    new_character_name = new_character_name:gsub("_", " ")
    sim_brain.actor_name = new_character_name
    se_actor:set_character_name(new_character_name)
  end

  -- Icon
  local new_character_icon = config:r_value("character_creation", "new_game_icon", 0, "")
  if (new_character_icon and new_character_icon ~= "" and binder.character_icon == nil) then
    binder.character_icon = new_character_icon
    config:w_value("character_creation", "new_game_icon")
    need_save = true
  end

  -- Faction
  local faction = config:r_value("character_creation", "new_game_faction", 0, "")

  -- Check if DRX Questlines addon is available
  local drx_ini = ini_file("misc\\task_manager.ltx")
  local drx = drx_ini:section_exist("drx_sl_find_wish_granter_task") and true or false

  if (faction and faction ~= "") then
    config:w_value("character_creation", "new_game_faction")
    need_save = true

    -- Faction Spawn Position
    local start_location = config:r_value("character_creation", "new_game_map")

    if start_location and start_location ~= "" then
      start_pos = {}
      table.insert(start_pos, ini_map:r_float_ex(start_location, "lvid"))
      table.insert(start_pos, ini_map:r_float_ex(start_location, "gvid"))
      table.insert(
        start_pos,
        vector():set(
          ini_map:r_float_ex(start_location, "x"),
          ini_map:r_float_ex(start_location, "y"),
          ini_map:r_float_ex(start_location, "z")
        )
      )
    end

    -- Enable the story quests, or disable their components depending on player choice and faction.
    if (axr_main.config:r_value("character_creation", "new_game_azazel_mode", 1, false)) then
      -- Compatibility with many story-specific mechanics.
      give_info("story_mode_disabled")
      -- Turn off the Miracle Machine:
      give_info("yan_labx16_switcher_1_off")
      give_info("yan_labx16_switcher_2_off")
      give_info("yan_labx16_switcher_3_off")
      give_info("yan_labx16_switcher_primary_off")

      -- Turn off the Brain Scorcher:
      give_info("bar_deactivate_radar_done")

      -- Turn off the Generators:
      give_info("warlab_deactivate_generators_done")
    else
      -- Compatibility with many story-specific mechanics.
      give_info("story_mode_disabled")

      -- Give deactivate Brain Scorcher task:
      if (faction ~= "monolith") and drx then
        task_manager.get_task_manager():give_task("turn_off_brain_scorcher")
      else
        -- Turn off the Miracle Machine:
        give_info("yan_labx16_switcher_1_off")
        give_info("yan_labx16_switcher_2_off")
        give_info("yan_labx16_switcher_3_off")
        give_info("yan_labx16_switcher_primary_off")

        -- Turn off the Brain Scorcher:
        give_info("bar_deactivate_radar_done")

        -- Turn off the Generators:
        give_info("warlab_deactivate_generators_done")
      end

      if drx then
        -- Determine total number of storyline tasks to complete for this game:
        alun_utils.save_var(db.actor, "drx_sl_total_task_number", math.random(8, 12)) -- Set to range of total meet honcho tasks to complete to finish game
        alun_utils.save_var(db.actor, "drx_sl_current_task_number", 1)

        -- Determine first honcho to start at:
        local start_game_honcho = ""
        if (faction == "stalker") then
          start_game_honcho = "esc_m_trader" -- Loner, Sidorovich
        elseif (faction == "dolg") then
          start_game_honcho = "bar_dolg_general_petrenko_stalker" -- Duty, Petrenko
        elseif (faction == "freedom") then
          start_game_honcho = "mil_smart_terrain_7_7_freedom_leader_stalker" -- Freedom, Lukash
        elseif (faction == "csky") then
          start_game_honcho = "mar_smart_terrain_base_stalker_leader_marsh" -- Clear Sky, Cold
        elseif (faction == "ecolog") then
          start_game_honcho = "yan_stalker_sakharov" -- Ecologist, Sakharov
        elseif (faction == "killer") then
          start_game_honcho = "cit_killers_merc_trader_stalker" -- Mercenary, Dushman
        elseif (faction == "army") then
          start_game_honcho = "agr_smart_terrain_1_6_near_2_military_colonel_kovalski" -- Military, Kuznetsov
        elseif (faction == "bandit") then
          start_game_honcho = "zat_b7_bandit_boss_sultan" -- Bandit, Sultan
        elseif (faction == "renegate") then
          start_game_honcho = "zat_b7_bandit_boss_sultan" -- Bandit, Sultan
        elseif (faction == "monolith") then
          start_game_honcho = "pri_monolith_monolith_trader_stalker" -- Monolith, Rabbit
        else
          printf("DRX SL no available game start honchos !!")
        end

        -- Build list of available start game versions for start game honcho:
        honcho_start_ltx_file = ini_file("misc\\task_manager.ltx")
        local honcho_start_list = {}
        local honcho_start_id = ""
        local i = 1
        while (true) do
          honcho_start_id = ("drx_sl_" .. start_game_honcho .. "_start_game_" .. i)
          if (honcho_start_ltx_file:section_exist(honcho_start_id)) then
            table.insert(honcho_start_list, honcho_start_id)
            i = (i + 1)
          else
            break
          end
        end

        -- Send actor to start game at current honcho:
        if (#honcho_start_list > 0) then
          math.randomseed(device():time_global())
          honcho_start_id = honcho_start_list[math.random(#honcho_start_list)]
          printf(("DRX SL current storyline task: " .. honcho_start_id))
          alun_utils.save_var(db.actor, "drx_sl_start_task", honcho_start_id)
          alun_utils.save_var(db.actor, "drx_sl_current_honcho", start_game_honcho)
          give_info(("drx_sl_start_game_" .. start_game_honcho)) -- (\configs\gameplay\info_portions.xml)
          task_manager.get_task_manager():give_task(honcho_start_id)
        else
          printf(("DRX SL no start game tasks available for " .. start_game_honcho .. " !!"))
        end
      end
    end

    config:w_value("character_creation", "new_game_story_mode", "") -- clear value

    db.actor:set_character_community("actor_" .. faction, 0, 0)

    -- Reset player goodwill
    local communities = alun_utils.get_communities_list()
    for i, community in pairs(communities) do
      relation_registry.set_community_goodwill(community, 0, 0)
    end

    -- Money
    local money = config:r_value("character_creation", "new_game_money", 2)
    if money and money ~= "" then
      db.actor:give_money(-db.actor:money() + money)
    end
    config:w_value("character_creation", "new_game_money")

    -- Loadout
    local sim = alife()
    local loadout = config:r_value("character_creation", "new_game_loadout", 0, nil)
    local ammo_table = {}
    if loadout and loadout ~= "" then
      local t = alun_utils.str_explode(loadout, ",")
      for i = 1, #t do
        if ini:section_exist(t[i]) then
          if ini:r_string_ex(t[i], "ammo_class") then
            local slot = ini:r_float_ex(t[i], "slot")
            if slot and ((slot == 1) or (slot == 2)) then -- retarded way to know that we are dealing with weapon
              local ammo = ini:r_string_ex(t[i], "ammo_class")
              ammo = alun_utils.str_explode(ammo, ",")
              ammo = ammo[1] --ammo[math.random(#ammo)]
              local box_size = (ini:r_float_ex(ammo, "box_size") or 50)
              local count = (box_size < 30) and 2 or 1
              for j = 1, count do
                ammo_table[#ammo_table + 1] = ammo
              end
            end
          end
          sim:create(t[i], db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), 0)
        end
      end
    end
    for i = 1, #ammo_table do
      sim:create(ammo_table[i], db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), 0)
    end
    config:w_value("character_creation", "new_game_loadout")

    se_actor:set_profile_name("actor_" .. faction)
  end
  --[[
	-- Loading economy values from save file
	axr_main.config:w_value("mm_options","multi_rewards_goodwill", utils.round(alife_storage_manager.get_state().economy_goodwill,2))
	axr_main.config:w_value("mm_options","multi_rewards_money", utils.round(alife_storage_manager.get_state().economy_money,2))
	axr_main.config:w_value("mm_options","multi_wpn_conditions", utils.round(alife_storage_manager.get_state().economy_wpn,2))
	axr_main.config:w_value("mm_options","multi_loot", utils.round(alife_storage_manager.get_state().economy_loot,2))
	--]]
  if (need_save) then
    config:save()
  end
end

local function actor_on_first_update(binder, delta)
  -- Survival mode
  if (IsSurvivalMode()) then
    game_relations.change_factions_community_num("zombied", 0, -5000)
    game_relations.change_factions_community_num("monolith", 0, -5000)

    local faction = character_community(db.actor):sub(7)
    if (ini:section_exist("survival_squad_" .. faction) and start_pos) then
      local sim = alife()
      local squad = sim:create("survival_squad_" .. faction, start_pos[3], start_pos[1], start_pos[2])
      if (squad) then
        axr_companions.companion_squads[squad.id] = squad
        squad:create_npc(nil, start_pos[3], start_pos[1], start_pos[2])
        for k in squad:squad_members() do
          local se_obj = k.object or k.id and sim:object(k.id)
          if (se_obj) then
            game_relations.change_factions_community_num("zombied", k.id, -5000)
            SIMBOARD:setup_squad_and_group(se_obj)

            utils.se_obj_save_var(se_obj.id, se_obj:name(), "companion", true)
            utils.se_obj_save_var(se_obj.id, se_obj:name(), "companion_cannot_dismiss", true)
          end
        end
      end
    end
  end

  if start_pos and #start_pos == 3 then
    ChangeLevel(start_pos[3], start_pos[1], start_pos[2], vector():set(0, 0, 0))
  end
end

local function actor_on_before_death() -- Ironman: second wind
  if not (USE_MARSHAL) then
    return
  end

  local uuid = alife_storage_manager.get_state().uuid
  if not (uuid) then
    return -- not in hardcore mode
  end

  local fs = getFS()
  local flist = fs:file_list_open_ex("$game_saves$", bit_or(FS.FS_ListFiles, FS.FS_RootOnly), "*.scoc")
  local f_cnt = flist:Size()

  for it = 0, f_cnt - 1 do
    local file = flist:GetAt(it)
    local file_name = string.sub(file:NameFull(), 0, (string.len(file:NameFull()) - string.len(".scoc")))

    local path = fs:update_path("$game_saves$", "") .. file_name .. ".scoc"
    local f = io.open(path, "rb")
    if (f) then
      local data = f:read("*all")
      f:close()
      if (data) then
        local decoded = alife_storage_manager.decode(data)
        if (decoded and decoded.uuid == uuid) then
          decoded.death_limit = decoded.death_limit or 3
          decoded.death_count = (decoded.death_count or 0) + 1
          if (decoded.death_count >= decoded.death_limit) then
            ui_load_dialog.delete_save_game(file_name)
          else
            local f = io.open(path, "wb")
            if (f) then
              local encoded = marshal.encode(decoded)
              if (encoded) then
                f:write(encoded)
              end
              f:close()
            end
          end
        end
      end
    end
  end
end

function on_game_start()
  RegisterScriptCallback("on_game_load", on_game_load)
  RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
  RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
end

--==============================================================================--
-------------------------------------< GUI >--------------------------------------
--==============================================================================--
class "faction_ui"(CUIScriptWnd)

function faction_ui:__init(owner)
  super()
  self.owner = owner

  -- Tables
  self.table_faction = {
    "stalker",
    "bandit",
    "csky",
    "dolg",
    "freedom",
    "killer",
    "army",
    "ecolog",
    "monolith",
    "mirotvorec",
    "isg",
    "darkstalker",
    "varyag",
    "slizni",
    "velhan",
    "fantom",
    "ryskuspecnaz",
    "renegate",
    "veter",
    "osoznanie",
    "alfa",
    "apocalypse",
    "adinkvizicia",
    "voenstal",
    "hunter",
    "sby",
    "angel",
    "posleduden",
    "greh",
    "zombied"
  }
  self.table_enabled_faction = {}
  self.table_icon = {}
  self.table_map = {}
  self.table_loadout = {}
  self.table_inv = {}
  self.table_difficulty_money = {
    novice = 3000,
    stalker = 1500,
    veteran = 500,
    master = 0
  }
  self.table_difficulty = {"novice", "stalker", "veteran", "master"}
  self.table_sectors = {
    "default",
    "vs_angel",
    "vs_slizni",
    "vs_renegate",
    "vs_monolith",
    "vs_sby",
    "vs_greh",
    "vs_stalker",
    "vs_varyag",
    "vs_apocalypse",
    "vs_adinkvizicia",
    "vs_freedom",
    "vs_osoznanie",
    "vs_bandit",
    "vs_csky",
    "vs_isg",
    "vs_darkstalker",
    "vs_mirotvorec",
    "vs_alfa",
    "vs_dolg",
    "vs_fantom",
    "vs_zombied",
    "vs_ecolog",
    "vs_voenstal",
    "vs_velhan",
    "vs_killer",
    "vs_veter",
    "vs_ryskuspecnaz",
    "vs_hunter",
    "vs_army",
    "empty"
  }
  self.table_relations = {
    "default",
    "battle_royale",
    "all_vs_all",
    "all_vs_actor",
    "all_vs_stalker",
    "all_vs_bandit",
    "all_vs_csky",
    "all_vs_army",
    "all_vs_freedom",
    "all_vs_dolg",
    "all_vs_ecolog",
    "all_vs_killer",
    "all_vs_monolith",
    "all_vs_zombied",
    "all_vs_isg",
    "all_vs_darkstalker",
    "all_vs_renegate",
    "all_vs_varyag",
    "all_vs_slizni",
    "all_vs_velhan",
    "all_vs_fantom",
    "all_vs_veter",
    "all_vs_osoznanie",
    "all_vs_alfa",
    "all_vs_apocalypse",
    "all_vs_adinkvizicia",
    "all_vs_hunter",
    "all_vs_voenstal",
    "all_vs_mirotvorec",
    "all_vs_ryskuspecnaz",
    "all_vs_sby",
    "all_vs_angel",
    "all_vs_posleduden",
    "all_vs_greh"
  }

  self.table_leader = {
    "default",
    "disabled"
  }

  self.table_hardcore_lives = {}
  local n = ini_opt:line_count("new_game_hardcore_lives") or 0
  for i = 0, n - 1 do
    local result, id, value = ini_opt:r_line("new_game_hardcore_lives", i, "", "")
    local t = alun_utils.str_explode(value, ",")
    local size = #self.table_hardcore_lives + 1
    self.table_hardcore_lives[size] = {}
    self.table_hardcore_lives[size][1] = tonumber(t[1])
    self.table_hardcore_lives[size][2] = tostring(t[2])
  end

  self.table_hardcore_regen = {{nil, "st_off"}}
  local n = ini_opt:line_count("new_game_hardcore_regen") or 0
  for i = 0, n - 1 do
    local result, id, value = ini_opt:r_line("new_game_hardcore_regen", i, "", "")
    local t = alun_utils.str_explode(value, ",")
    local size = #self.table_hardcore_regen + 1
    self.table_hardcore_regen[size] = {}
    self.table_hardcore_regen[size][1] = tonumber(t[1])
    self.table_hardcore_regen[size][2] = tostring(t[2])
  end

  self.table_timer = {{nil, "st_off"}}
  local n = ini_opt:line_count("new_game_timer") or 0
  for i = 0, n - 1 do
    local result, id, value = ini_opt:r_line("new_game_timer", i, "", "")
    local t = alun_utils.str_explode(value, ",")
    local size = #self.table_timer + 1
    self.table_timer[size] = {}
    self.table_timer[size][1] = tonumber(t[1])
    self.table_timer[size][2] = tostring(t[2])
  end

  -- Selected choices
  self.selected_faction = self.table_faction[1]
  self.selected_icon = nil
  self.selected_map = nil
  self.selected_money = nil
  self.selected_difficulty = self.table_difficulty[2]
  self.selected_sector = self.table_sectors[1]
  self.selected_relations = self.table_relations[1]
  self.selected_leader = self.table_leader[1]
  self.selected_hardcore_lives = self.table_hardcore_lives[1]
  self.selected_hardcore_regen = self.table_hardcore_regen[1]
  self.selected_timer = self.table_timer[1]
  self.points_left = ini_itm:r_float_ex("points", "total_points") or 1000
  self.points_used = 0

  for i = 1, #self.table_faction do
    local faction = self.table_faction[i]

    self.table_enabled_faction[faction] = true
  end

  -- Utility
  self.access = true

  -- Prepare
  self:SetWndRect(Frect():set(0, 0, 1024, 768))
  self:Enable(true)

  local xml = CScriptXmlInit()
  self.xml = xml
  xml:ParseFile("ui_mm_faction_select.xml")

  xml:InitStatic("background", self)

  -- Main
  self:Main_Controls()
  self:Main_CallBacks()

  -- Faction Select
  self:PopupFaction_Controls()
  self:PopupFaction_Callbacks()
  self:PopupFaction_Show(false)

  -- Icon Select
  self:PopupIcon_Controls()
  self:PopupIcon_Callbacks()
  self:PopupIcon_Show(false)
end

function faction_ui:__finalize()
end

function faction_ui:Main_Controls()
  local xml = self.xml

  -- Background
  self.dialog = xml:InitStatic("main_dialog:frame_back", self)

  -- Boxes
  self.box_map = xml:InitStatic("main_dialog:box_map", self.dialog)
  self.box_faction = xml:InitStatic("main_dialog:box_faction", self.dialog)
  self.box_icon = xml:InitStatic("main_dialog:box_icon", self.dialog)

  self.box_item = xml:InitStatic("main_dialog:box_item", self.dialog)
  self.box_item_temp = xml:InitStatic("main_dialog:box_item", self.dialog)

  -- Main frame
  self.main_frame = xml:InitStatic("main_dialog:frame_front", self.dialog)

  -- Interactive Text
  self.text_descr = xml:InitTextWnd("main_dialog:text_descr", nil)
  self.scroll_desc = xml:InitScrollView("main_dialog:scroll_desc", self.dialog)
  self.scroll_desc:AddWindow(self.text_descr, true)
  self.text_descr:SetAutoDelete(false)

  self.character_name = xml:InitEditBox("main_dialog:input_name", self.dialog)
  self:Register(self.character_name, "input_name")
  self.character_name:SetText(gs("pri_b305_strelok_name")) -- Set Default Name

  self.text_relations = xml:InitTextWnd("main_dialog:text_relations", self.dialog)
  self.text_relations:SetText("%c[0,250,250,250]" .. gs("st_mm_new_game_relations"))
  self.text_money = xml:InitTextWnd("main_dialog:text_money", self.dialog)
  self.text_points_left = xml:InitTextWnd("main_dialog:text_points_left", self.dialog)
  self.text_points_used = xml:InitTextWnd("main_dialog:text_points_used", self.dialog)

  self.text_item_descr = xml:InitTextWnd("main_dialog:text_item_descr", nil)
  self.scroll_item_desc = xml:InitScrollView("main_dialog:scroll_item_desc", self.dialog)
  self.scroll_item_desc:AddWindow(self.text_item_descr, true)
  self.text_item_descr:SetAutoDelete(false)

  self.text_item_name = xml:InitTextWnd("main_dialog:text_item_name", self.dialog)
  self.text_item_points = xml:InitTextWnd("main_dialog:text_item_points", self.dialog)

  -- Static Text
  xml:InitStatic("main_dialog:cap_character", self.dialog)
  xml:InitStatic("main_dialog:cap_inventory", self.dialog)
  xml:InitStatic("main_dialog:cap_loadout", self.dialog)

  xml:InitStatic("main_dialog:cap_name", self.dialog)
  xml:InitStatic("main_dialog:cap_money", self.dialog)
  xml:InitStatic("main_dialog:cap_points_left", self.dialog)
  xml:InitStatic("main_dialog:cap_points_used", self.dialog)

  self:InitCheckFactions()

  -- Main Buttons
  local btn = xml:Init3tButton("main_dialog:btn_start", self.dialog)
  self:Register(btn, "btn_start")

  btn = xml:Init3tButton("main_dialog:btn_back", self.dialog)
  self:Register(btn, "btn_back")

  btn = xml:Init3tButton("main_dialog:btn_random", self.dialog)
  self:Register(btn, "btn_random")

  btn = xml:Init3tButton("main_dialog:btn_faction", self.dialog)
  self:Register(btn, "btn_faction")

  btn = xml:Init3tButton("main_dialog:btn_icon", self.dialog)
  self:Register(btn, "btn_icon")

  self.list_map = xml:InitComboBox("main_dialog:list_map", self.dialog)
  self.list_map:SetAutoDelete(true)
  self:Register(self.list_map, "list_map")

  -- Item Lists
  self.list_inv = xml:InitListBox("main_dialog:list_inv", self.dialog)
  self.list_inv:ShowSelectedItem(true)
  self.list_inv:Show(true)
  self:Register(self.list_inv, "list_inv")

  self.list_loadout = xml:InitListBox("main_dialog:list_loadout", self.dialog)
  self.list_loadout:ShowSelectedItem(true)
  self.list_loadout:Show(true)
  self:Register(self.list_loadout, "list_loadout")

  self.ck_reset = xml:Init3tButton("main_dialog:check_reset", self.dialog)
  self:Register(self.ck_reset, "check_reset")

  -- Update info
  self:UpdateAll(false)

  -- Options
  self.scroll_options = xml:InitScrollView("main_dialog:scroll_options", self.dialog)
  self.templ_options = xml:InitStatic("main_dialog:templ_options", nil)
  if (USE_MARSHAL) then
    self.list_difficulty_cap = xml:InitStatic("main_dialog:list_difficulty_cap", self.dialog)
    self.list_difficulty = xml:InitComboBox("main_dialog:list_difficulty", self.dialog)
    self.list_difficulty:SetAutoDelete(true)
    self:Register(self.list_difficulty, "list_difficulty")
    self:LoadDifficulty()

    self.list_sectors_cap = xml:InitStatic("main_dialog:list_sectors_cap", self.dialog)
    self.list_sectors = xml:InitComboBox("main_dialog:list_sectors", self.dialog)
    self.list_sectors:SetAutoDelete(true)
    self:Register(self.list_sectors, "list_sectors")
    self:LoadSectors()

    self.list_relations_cap = xml:InitStatic("main_dialog:list_relations_cap", self.dialog)
    self.list_relations = xml:InitComboBox("main_dialog:list_relations", self.dialog)
    self.list_relations:SetAutoDelete(true)
    self:Register(self.list_relations, "list_relations")
    self:LoadRelations()

    self.list_leader_cap = xml:InitStatic("main_dialog:list_leader_cap", self.dialog)
    self.list_leader = xml:InitComboBox("main_dialog:list_leader", self.dialog)
    self.list_leader:SetAutoDelete(true)
    self:Register(self.list_leader, "list_leader")
    self:LoadLeaderList()

    self.ck_hardcore_cap = xml:InitStatic("main_dialog:cap_check_hardcore", self.dialog)
    self.ck_hardcore = xml:InitCheck("main_dialog:check_hardcore", self.dialog)
    self:Register(self.ck_hardcore, "check_hardcore")

    self.ck_survival_cap = xml:InitStatic("main_dialog:cap_check_survival", self.dialog)
    self.ck_survival = xml:InitCheck("main_dialog:check_survival", self.dialog)
    self:Register(self.ck_survival, "check_survival")

    self.ck_azazel_cap = xml:InitStatic("main_dialog:cap_check_azazel", self.dialog)
    self.ck_azazel = xml:InitCheck("main_dialog:check_azazel", self.dialog)
    self:Register(self.ck_azazel, "check_azazel")

    self.ck_campfire_cap = xml:InitStatic("main_dialog:cap_check_campfire", self.dialog)
    self.ck_campfire = xml:InitCheck("main_dialog:check_campfire", self.dialog)
    self:Register(self.ck_campfire, "check_campfire")

    self.ck_conditions_cap = xml:InitStatic("main_dialog:cap_check_conditions", self.dialog)
    self.ck_conditions = xml:InitCheck("main_dialog:check_conditions", self.dialog)
    self:Register(self.ck_conditions, "check_conditions")

    self.list_hardcore_lives_cap = xml:InitStatic("main_dialog:cap_list_hardcore_lives", self.dialog)
    self.list_hardcore_lives = xml:InitComboBox("main_dialog:list_hardcore_lives", self.dialog)
    self.list_hardcore_lives:SetAutoDelete(true)
    self:Register(self.list_hardcore_lives, "list_hardcore_lives")
    self:LoadHardcoreLives()

    self.list_hardcore_regen_cap = xml:InitStatic("main_dialog:cap_list_hardcore_regen", self.dialog)
    self.list_hardcore_regen = xml:InitComboBox("main_dialog:list_hardcore_regen", self.dialog)
    self.list_hardcore_regen:SetAutoDelete(true)
    self:Register(self.list_hardcore_regen, "list_hardcore_regen")
    self:LoadHardcoreRegen()

    self.list_timer_cap = xml:InitStatic("main_dialog:cap_list_timer", self.dialog)
    self.list_timer = xml:InitComboBox("main_dialog:list_timer", self.dialog)
    self.list_timer:SetAutoDelete(true)
    self:Register(self.list_timer, "list_timer")
    self:LoadTimer()

    self.message_box_war = CUIMessageBoxEx()
    self:Register(self.message_box_war, "msg_box")

    self.ck_states = {
      ["ck_survival"] = false,
      ["ck_hardcore"] = false,
      ["ck_campfire"] = false,
      ["ck_azazel"] = false,
      ["ck_conditions"] = false,
      ["list_difficulty"] = false,
      ["list_hardcore_lives"] = false,
      ["list_hardcore_regen"] = false,
      ["list_timer"] = false,
      ["list_relations"] = false,
      ["list_leader"] = false,
      ["list_sectors"] = false
    }
  end
  self.scroll_options:AddWindow(self.templ_options, true)
  self.templ_options:SetAutoDelete(false)

  -- Hint Window
  self.hint_wnd = xml:InitFrame("hint_wnd:background", self)
  self.hint_wnd:SetAutoDelete(false)
  self.hint_wnd_text = xml:InitTextWnd("hint_wnd:text", self.hint_wnd)
  self.hint_wnd:Show(false)

  -- Message Window
  self.msg_wnd = xml:InitFrame("hint_wnd:background", self)
  self.msg_wnd:SetAutoDelete(false)
  self.msg_wnd_text = xml:InitTextWnd("hint_wnd:text", self.msg_wnd)
  self.msg_wnd_text:SetTextAlignment(2)

  self.msg_wnd:Show(false)
  self.msg_wnd:SetColor(GetARGB(255, 0, 0, 0))

  self.list_difficulty:Enable(true)
  self.list_sectors:Enable(true)
  self.list_relations:Enable(true)
  self.list_leader:Enable(true)
  self.list_timer:Enable(true)
  self.list_hardcore_regen:Enable(true)
  self.list_hardcore_lives:Enable(true)
  self.list_map:Enable(true)
  self.ck_hardcore:Enable(true)
  self.ck_survival:Enable(true)
  self.ck_campfire:Enable(true)
  self.ck_azazel:Enable(true)
  self.ck_conditions:Enable(true)
end

function faction_ui:Main_CallBacks()
  self:AddCallback("btn_start", ui_events.BUTTON_CLICKED, self.OnStartGame, self)
  self:AddCallback("btn_random", ui_events.BUTTON_CLICKED, self.OnRandomize, self)
  self:AddCallback("btn_back", ui_events.BUTTON_CLICKED, self.OnQuit, self)

  self:AddCallback("btn_faction", ui_events.BUTTON_CLICKED, self.OnFactionClicked, self)
  self:AddCallback("btn_icon", ui_events.BUTTON_CLICKED, self.OnIconClicked, self)

  self:AddCallback("list_map", ui_events.LIST_ITEM_SELECT, self.OnSelectMap, self)
  self:AddCallback("check_reset", ui_events.BUTTON_CLICKED, self.OnCheckResetList, self)

  self:AddCallback("list_inv", ui_events.LIST_ITEM_CLICKED, self.OnInventoryClicked, self)
  self:AddCallback("list_inv", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnInventoryDbClicked, self)
  self:AddCallback("list_loadout", ui_events.LIST_ITEM_CLICKED, self.OnLoadoutClicked, self)
  self:AddCallback("list_loadout", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnLoadoutDbClicked, self)

  self:AddCallback("list_difficulty", ui_events.LIST_ITEM_SELECT, self.OnSelectDifficulty, self)
  self:AddCallback("list_sectors", ui_events.LIST_ITEM_SELECT, self.OnSelectSector, self)
  self:AddCallback("list_relations", ui_events.LIST_ITEM_SELECT, self.OnSelectRelations, self)
  self:AddCallback("list_leader", ui_events.LIST_ITEM_SELECT, self.OnSelectLeader, self)
  self:AddCallback("list_hardcore_lives", ui_events.LIST_ITEM_SELECT, self.OnSelectHardcoreLives, self)
  self:AddCallback("list_hardcore_regen", ui_events.LIST_ITEM_SELECT, self.OnSelectHardcoreRegen, self)
  self:AddCallback("list_timer", ui_events.LIST_ITEM_SELECT, self.OnSelectTimer, self)

  self:AddCallback("msg_box", ui_events.MESSAGE_BOX_YES_CLICKED, self.OnMsgYes, self)
end

function faction_ui:Update()
  CUIScriptWnd.Update(self)

  if (not self.access) then
    self.hint_wnd:Show(false)
    return
  end

  -- Warning messages timer
  if (self.msg_wnd_timer and time_global() > self.msg_wnd_timer) then
    self.msg_wnd_timer = nil
    self.msg_wnd:Show(false)
  end

  for ck_name, v in pairs(self.ck_states) do
    if (self[ck_name] and self[ck_name]:IsCursorOverWindow()) then
      local str = ""
      if (ck_name == "box_faction") then
        str = strformat(gs("st_mm_box_faction_desc"), gs("st_faction_" .. self.selected_faction))
        if (self.selected_faction == "bandit") then
          str = "cheeki breeki"
        end
      elseif ck_name == "list_sectors" and self.selected_sector then
        str = gs(strformat("st_mm_list_sector_%s_desc", self.selected_sector))
      elseif ck_name == "list_relations" and self.selected_relations == "all_vs_actor" then
        str = gs("st_mm_list_relation_all_vs_actor_desc")
      elseif ck_name == "list_relations" and self.selected_relations == "battle_royale" then
        str = gs("st_mm_list_relation_battle_royale_desc")
      else
        str = gs("st_mm_" .. ck_name .. "_desc")
      end
      self:SetHint(str)
      return
    end
  end
  self.hint_wnd:Show(false)
end

function faction_ui:SetMsg(text, tmr)
  if (text == "") then
    return
  end
  self.msg_wnd:Show(true)
  self.msg_wnd_text:SetText(text)
  self.msg_wnd_text:AdjustHeightToText()
  self.msg_wnd_text:SetWndSize(vector2():set(820, self.msg_wnd_text:GetHeight() + 44))
  self.msg_wnd_text:SetWndPos(vector2():set(0, 20))

  self.msg_wnd:SetWndSize(vector2():set(820, self.msg_wnd_text:GetHeight() + 44))
  self.msg_wnd:SetWndPos(vector2():set(0, 80))

  self.msg_wnd_timer = time_global() + 1000 * tmr
end

function faction_ui:SetHint(text, pos)
  if (text == "") then
    return
  end

  self.hint_wnd:Show(true)
  self.hint_wnd_text:SetText(text)
  self.hint_wnd_text:AdjustHeightToText()
  local size = vector2():set(self.hint_wnd:GetWidth(), self.hint_wnd_text:GetHeight() + 66)
  self.hint_wnd:SetWndSize(size)

  pos = pos or GetCursorPosition()
  pos.y = pos.y - self.hint_wnd:GetHeight()
  pos.x = pos.x - self.hint_wnd:GetWidth()
  self.hint_wnd:SetWndPos(pos)

  FitInRect(self.hint_wnd, Frect():set(0, 0, 1024, 768), 0, 100)
end

--=======================================< Faction Select Pop-up >=======================================--
function faction_ui:PopupFaction_Controls()
  local xml = self.xml

  -- Main
  self.black_1 = xml:InitStatic("main_dialog:popup_faction:frame_black", self.dialog)
  self.dialog_1 = xml:InitStatic("main_dialog:popup_faction:frame", self.dialog)

  -- Static Text
  self.cap_faction = xml:InitStatic("main_dialog:popup_faction:cap_faction", self.dialog_1)

  -- Faction buttons
  self.scroll_faction = xml:InitScrollView("main_dialog:popup_faction:scroll_faction", self.dialog_1)
  self.templ_faction = xml:InitStatic("main_dialog:popup_faction:templ_faction", nil)
  self.btn_faction = {}
end

function faction_ui:PopupFaction_Callbacks()
  for i = 1, #self.table_faction do
    local faction = self.table_faction[i]
    local func_name = strformat("OnFaction_%s", faction)

    self[func_name] = function()
      self:OnFactionSelect(faction)
    end

    self:AddCallback("btn_" .. faction, ui_events.BUTTON_CLICKED, self[func_name], self)
  end
end

function faction_ui:OnEnabledFaction(faction)
  local check_name = strformat("check_faction_%s", faction)

  self.table_enabled_faction[faction] = self[check_name]:GetCheck()
end

function faction_ui:InitCheckFactions()
  local posX = 18
  local posY = 56

  for i = 1, #self.table_faction do
    local faction = self.table_faction[i]
    local func_name = strformat("OnEnabledFaction_%s", faction)
    local check_cap_name = strformat("cap_check_faction_%s", faction)
    local check_name = strformat("check_faction_%s", faction)
    local color = "%c[0,150,150,50]Х %c[0,150,150,150]"

    self[check_cap_name] = self.xml:InitStatic(strformat("main_dialog:%s", check_cap_name), self.dialog)
    self[check_name] = self.xml:InitCheck(strformat("main_dialog:%s", check_name), self.dialog)
    self:Register(self[check_name], check_name)

    local relation = relation_registry.community_relation(self.selected_faction, faction)
    if (relation >= 1000) then
      color = "%c[0,150,150,150]Х %c[0,50,175,50]"
    elseif (relation <= -1000) then
      color = "%c[0,150,150,150]Х %c[0,175,50,50]"
    else
      color = "%c[0,150,150,150]Х %c[0,175,175,50]"
    end

    self[check_cap_name]:TextControl():SetText(strformat("%s %s", color, gs("st_faction_" .. faction)))
    self[check_cap_name]:SetWndPos(vector2():set(posX + 16, posY))
    self[check_name]:SetWndPos(vector2():set(posX, posY + 3))
    self[check_name]:SetCheck(true)
    self[func_name] = function()
      self:OnEnabledFaction(faction)
    end

    self:AddCallback(check_name, ui_events.BUTTON_CLICKED, self[func_name], self)

    posY = posY + 12
  end
end

function faction_ui:PopupFaction_Show(state)
  local xml = self.xml

  self.black_1:Show(state)
  self.dialog_1:Show(state)
  self.cap_faction:Show(state)
  self.scroll_faction:Clear()
  if state then
    self.access = false

    for i = 1, #self.table_faction do
      self.btn_faction[i] =
        xml:Init3tButton("main_dialog:popup_faction:btn_" .. self.table_faction[i], self.templ_faction)
      local x, y =
        self:GetAxis_Icon(
        self.scroll_faction,
        self.btn_faction[i],
        7,
        7,
        math.ceil(i / 7),
        (i > 7 and i < 15 and i - 7) or (i > 14 and i < 22 and i - 14) or (i > 21 and i < 29 and i - 21) or
          (i > 28 and i - 28) or
          i
      )
      self.btn_faction[i]:SetWndPos(vector2():set(x, y))
      self:Register(self.btn_faction[i], "btn_" .. self.table_faction[i])
    end
    self.scroll_faction:AddWindow(self.templ_faction, true)
    self.templ_faction:SetAutoDelete(false)
  else
    self.access = true
  end
end

function faction_ui:OnFactionSelect(faction)
  self.selected_faction = faction
  self:UpdateAll(false, self.selected_faction)
  self:PopupFaction_Show(false)

  self.list_difficulty:Enable(true)
  self.list_sectors:Enable(true)
  self.list_relations:Enable(true)
  self.list_leader:Enable(true)
  self.list_timer:Enable(true)
  self.list_hardcore_regen:Enable(true)
  self.list_hardcore_lives:Enable(true)
  self.list_map:Enable(true)
  self.ck_hardcore:Enable(true)
  self.ck_survival:Enable(true)
  self.ck_campfire:Enable(true)
  self.ck_azazel:Enable(true)
  self.ck_conditions:Enable(true)
end

--=======================================< Icon Select Pop-up >=======================================--
function faction_ui:PopupIcon_Controls()
  local xml = self.xml

  -- Main
  self.black_2 = xml:InitStatic("main_dialog:popup_icon:frame_black", self.dialog)
  self.dialog_2 = xml:InitStatic("main_dialog:popup_icon:frame", self.dialog)

  -- Static Text
  self.cap_icon = xml:InitStatic("main_dialog:popup_icon:cap_icon", self.dialog_2)

  -- Faction buttons
  self.scroll_icon = xml:InitScrollView("main_dialog:popup_icon:scroll_icon", self.dialog_2)
  self.templ_icon = xml:InitStatic("main_dialog:popup_icon:templ_icon", nil)

  -- Size Reference
  self.tempy_icon = xml:InitStatic("main_dialog:popup_icon:temp_icon", self.dialog_2)

  self.btn_icon = {}
  self.temp_icon = {}
end

function faction_ui:PopupIcon_Callbacks()
  for i = 1, PORTRAITS_COUNT do
    local func_name = "OnIcon_" .. tostring(i)

    self[func_name] = function()
      self:OnIconSelect(i)
    end

    self:AddCallback("btn_icon_" .. tostring(i), ui_events.BUTTON_CLICKED, self[func_name], self)
  end
end

function faction_ui:PopupIcon_Show(state)
  local xml = self.xml

  self.black_2:Show(state)
  self.dialog_2:Show(state)
  self.cap_icon:Show(state)
  self.scroll_icon:Clear()
  if state then
    self.access = false

    local n = 10
    local x = 20
    local w = self.tempy_icon:GetWidth()
    local h = self.tempy_icon:GetHeight()
    for i = 1, PORTRAITS_COUNT do -- everything else is thrown outside
      if self.temp_icon[i] and self.btn_icon[i] then
        self.temp_icon[i]:SetWndPos(vector2():set(x + 200, 0))
        self.btn_icon[i]:SetWndPos(vector2():set(x + 200, 0))
        self.temp_icon[i]:Show(false)
        self.btn_icon[i]:Show(false)
      end
    end
    for i = 1, #self.table_icon do
      self.temp_icon[i] = xml:InitStatic("main_dialog:popup_icon:temp_icon", self.templ_icon)
      self.temp_icon[i]:InitTexture(self.table_icon[i])
      self.temp_icon[i]:SetStretchTexture(true)
      self.temp_icon[i]:SetWndSize(vector2():set(w, h))
      self.btn_icon[i] = xml:Init3tButton("main_dialog:popup_icon:btn_icon", self.templ_icon)

      self.temp_icon[i]:SetWndPos(vector2():set(x, n))
      self.btn_icon[i]:SetWndPos(vector2():set(x, n))

      self.temp_icon[i]:Show(true)
      self.btn_icon[i]:Show(true)

      self:Register(self.temp_icon[i], "btn_icon_" .. tostring(i))
      self:Register(self.btn_icon[i], "btn_icon_" .. tostring(i))
      n = n + h + 10
    end
    self.templ_icon:SetWndSize(vector2():set(self.templ_icon:GetWidth(), n - 2))
    self.scroll_icon:AddWindow(self.templ_icon, true)
    self.templ_icon:SetAutoDelete(false)
  else
    self.access = true
  end
end

function faction_ui:OnIconSelect(num)
  self.selected_icon = self.table_icon[num]
  self:UpdateIcon()
  self:PopupIcon_Show(false)
end

--=======================================< Prepare the droplists / Update the info >=======================================--
function faction_ui:LoadFaction(rand, faction)
  local pick = faction
  if (not pick) then
    pick = rand and self.table_faction[math.random(#self.table_faction)] or self.table_faction[1]
  end

  self.selected_faction = pick
  self.selected_money = self.table_difficulty_money[self.selected_difficulty]

  self:UpdateFaction()
  self:UpdateMoney()
end

function faction_ui:LoadIcon(rand)
  local def_icon = "ui_inGame2_no_data"
  self.table_icon = {}
  table.insert(self.table_icon, def_icon)

  local section = self.selected_faction .. "_portraits"
  local n = ini_ico:section_exist(section) and ini_ico:line_count(section) or 0
  for i = 0, n - 1 do
    local result, id, value = ini_ico:r_line(section, i, "", "")
    if (id ~= "") then
      table.insert(self.table_icon, id)
    end
  end

  local pick = rand and self.table_icon[math.random(#self.table_icon)] or def_icon

  self.selected_icon = pick
  self:UpdateIcon()
end

function get_location_text(smart_name)
  local level_name = ini_map:r_string(smart_name, "level_name")
  local level_text = GetString(level_name)
  local smart_text = sim_script_to_text.smart_names[smart_name] or smart_name

  return strformat("%s (%s)", smart_text, level_text)
end

function faction_ui:LoadMap(rand)
  self.table_map = {}

  local exist = ini_map:section_exist(self.selected_faction)

  if not exist then
    utils.error(
      "ƒл€ выбранной группировки отсутствует список локаций дл€ начального спавна. —писок можно сгенерировать в режиме отладки нажатием на клавишу L в главном меню только во врем€ игры. „тобы список сгенерировалс€, нужна€ группировка должна зан€ть хот€ бы 1 любую базу. —писок генерируетс€ из зан€тых группировками баз."
    )
  end

  local n = ini_map:line_count(self.selected_faction) or 0
  for i = 0, n - 1 do
    local _, id, _ = ini_map:r_line(self.selected_faction, i, "", "")
    local exist = ini_map:section_exist(id)

    if exist then
      local enabled = ini_map:r_string(id, "enabled")

      if enabled == "true" then
        table.insert(self.table_map, id)
      end
    end
  end

  self.list_map:ClearList()
  for i = 1, #self.table_map do
    self.list_map:AddItem(get_location_text(self.table_map[i]), i)
  end
  local pick = rand and self.table_map[math.random(#self.table_map)] or self.table_map[1]
  self.list_map:SetText(get_location_text(pick))

  self.selected_map = pick
  self:UpdateMap()
end

function faction_ui:LoadLoadout(rand)
  -- Reset
  self:ClearItem()
  self.points_used = 0
  self.points_left = ini_itm:r_float_ex("points", "total_points") or 1000
  self.text_points_used:SetText(tostring(self.points_used))
  self.text_points_left:SetText(tostring(self.points_left))

  local delet = {}
  for index = 0, self.list_loadout:GetSize() - 1 do
    local item = self.list_loadout:GetItemByIndex(index)
    delet[#delet + 1] = item
  end
  for i = 1, #delet do
    self.list_loadout:RemoveItem(delet[i])
  end

  delet = {}
  for index = 0, self.list_inv:GetSize() - 1 do
    local item = self.list_inv:GetItemByIndex(index)
    delet[#delet + 1] = item
  end
  for i = 1, #delet do
    self.list_inv:RemoveItem(delet[i])
  end

  -- Read
  self.table_inv = {}
  self.table_loadout = {}
  local n = ini_itm:line_count(self.selected_faction .. "_loadout") or 0
  for i = 0, n - 1 do
    local result, id, value = ini_itm:r_line(self.selected_faction .. "_loadout", i, "", "")
    if ini:section_exist(id) then
      local t = alun_utils.str_explode(value, ",")
      if (t[1] == "false") then
        for i = 1, tonumber(t[2]) do
          self.table_inv[#self.table_inv + 1] = {["name"] = id, ["points"] = 0}
        end
      elseif (t[1] == "true") then
        for i = 1, tonumber(t[2]) do
          self.table_loadout[#self.table_loadout + 1] = {["name"] = id, ["points"] = tonumber(t[3])}
        end
      end
    end
  end

  -- Update
  for i = 1, #self.table_inv do
    local _itm = set_list_text(i, self.table_inv[i].name, self.table_inv[i].points, false)
    self.list_inv:AddExistingItem(_itm)
  end
  for i = 1, #self.table_loadout do
    local _itm = set_list_text(i, self.table_loadout[i].name, self.table_loadout[i].points, true)
    self.list_loadout:AddExistingItem(_itm)
  end

  -- Pick randomly
  if (not rand) then
    return
  end

  local indx_tbl, pick_tbl = {}, {}
  for i = 1, self.list_loadout:GetSize() do
    indx_tbl[i] = i - 1
  end

  while (#indx_tbl > 1) do
    local j = math.random(#indx_tbl)
    local k = indx_tbl[j]
    table.remove(indx_tbl, j)
    pick_tbl[#pick_tbl + 1] = k
  end

  if (#pick_tbl < 1) then
    return
  end

  for i = 1, #pick_tbl do
    local _item = self.list_loadout:GetItemByIndex(pick_tbl[i])
    self:OnLoadoutDbClicked(_item)
  end
end

function faction_ui:LoadDifficulty(rand)
  self.list_difficulty:ClearList()

  for i = 1, #self.table_difficulty do
    self.list_difficulty:AddItem(gs("gd_" .. self.table_difficulty[i]), i)
  end

  local pick = rand and self.table_difficulty[math.random(#self.table_difficulty)] or self.table_difficulty[2]
  self.list_difficulty:SetText(gs("gd_" .. pick))
  self.selected_difficulty = pick
end

function faction_ui:LoadSectors(rand)
  self.list_sectors:ClearList()

  for i = 1, #self.table_sectors do
    self.list_sectors:AddItem(gs("sector_" .. self.table_sectors[i]), i)
  end

  local pick =
    rand and #self.table_sectors > 0 and self.table_sectors[math.random(#self.table_sectors)] or self.table_sectors[1]
  self.list_sectors:SetText(gs("sector_" .. pick))
  self.selected_sector = pick
end

function faction_ui:LoadRelations(rand)
  self.list_relations:ClearList()

  for i = 1, #self.table_relations do
    self.list_relations:AddItem(gs("relations_" .. self.table_relations[i]), i)
  end

  local pick = rand and self.table_relations[math.random(#self.table_relations)] or self.table_relations[1]
  self.list_relations:SetText(gs("relations_" .. pick))
  self.selected_relations = pick
end

function faction_ui:LoadLeaderList(rand)
  self.list_leader:ClearList()

  for i = 1, #self.table_leader do
    self.list_leader:AddItem(gs("st_leader_" .. self.table_leader[i]), i)
  end

  local pick = rand and self.table_leader[math.random(#self.table_leader)] or self.table_leader[1]
  self.list_leader:SetText(gs("st_leader_" .. pick))
  self.selected_leader = pick
end

function faction_ui:LoadHardcoreLives(rand)
  local str
  self.list_hardcore_lives:ClearList()
  for i = 1, #self.table_hardcore_lives do
    str = self.table_hardcore_lives[i][1] or ""
    self.list_hardcore_lives:AddItem(str .. " " .. gs(self.table_hardcore_lives[i][2]), i)
  end
  local pick =
    rand and self.table_hardcore_lives[math.random(#self.table_hardcore_lives)] or self.table_hardcore_lives[1]
  str = pick[1] or ""
  self.list_hardcore_lives:SetText(str .. " " .. gs(pick[2]))
  self.selected_hardcore_lives = pick
end

function faction_ui:LoadHardcoreRegen(rand)
  local str
  self.list_hardcore_regen:ClearList()
  for i = 1, #self.table_hardcore_regen do
    str = self.table_hardcore_regen[i][1] and tostring(utils.round(self.table_hardcore_regen[i][1] / 24)) or ""
    self.list_hardcore_regen:AddItem(str .. " " .. gs(self.table_hardcore_regen[i][2]), i)
  end
  local pick =
    rand and self.table_hardcore_regen[math.random(#self.table_hardcore_regen)] or self.table_hardcore_regen[1]
  str = pick[1] and tostring(utils.round(pick[1] / 24)) or ""
  self.list_hardcore_regen:SetText(str .. " " .. gs(pick[2]))
  self.selected_hardcore_regen = pick
end

function faction_ui:LoadTimer(rand)
  local str
  self.list_timer:ClearList()
  for i = 1, #self.table_timer do
    str = self.table_timer[i][1] or ""
    self.list_timer:AddItem(str .. " " .. gs(self.table_timer[i][2]), i)
  end
  local pick = rand and self.table_timer[math.random(#self.table_timer)] or self.table_timer[1]
  str = pick[1] or ""
  self.list_timer:SetText(str .. " " .. gs(pick[2]))
  self.selected_timer = pick
end

--=======================================< GUI Callbacks >=======================================-
function faction_ui:OnFactionClicked()
  if (not self.access) then
    return
  end

  self:PopupFaction_Show(true)

  self.list_difficulty:Enable(false)
  self.list_sectors:Enable(false)
  self.list_relations:Enable(false)
  self.list_leader:Enable(false)
  self.list_timer:Enable(false)
  self.list_hardcore_regen:Enable(false)
  self.list_hardcore_lives:Enable(false)
  self.list_map:Enable(false)
  self.ck_hardcore:Enable(false)
  self.ck_survival:Enable(false)
  self.ck_campfire:Enable(false)
  self.ck_azazel:Enable(false)
  self.ck_conditions:Enable(false)
end

function faction_ui:OnIconClicked()
  if (not self.access) then
    return
  end

  self:PopupIcon_Show(true)
end

function faction_ui:OnSelectMap()
  self.selected_map = self.table_map[self.list_map:CurrentID()]
  self:UpdateMap()
end

function faction_ui:OnInventoryClicked()
  if (not self.access) then
    return
  end

  local item = self.list_inv:GetSelectedItem()
  if not (item) then
    return
  end
  self:UpdateItem(item)
end

function faction_ui:OnInventoryDbClicked()
  if (not self.access) then
    return
  end

  local item = self.list_inv:GetSelectedItem()
  if not (item) then
    return
  end

  if not (item.allow) then
    return
  end

  local points = item.points
  self.points_used = self.points_used - points
  self.points_left = self.points_left + points

  self.text_points_used:SetText(tostring(self.points_used))
  self.text_points_left:SetText(tostring(self.points_left))

  local _itm = set_list_text(item.idx, item.name, item.points, true)
  self.list_loadout:AddExistingItem(_itm)
  self.list_inv:RemoveItem(item)

  self:ClearItem()
end

function faction_ui:OnLoadoutClicked()
  if (not self.access) then
    return
  end

  local item = self.list_loadout:GetSelectedItem()
  if not (item) then
    return
  end
  self:UpdateItem(item)
end

function faction_ui:OnLoadoutDbClicked(pick)
  if (not self.access) then
    return
  end

  local item = pick
  if (not item) then
    item = self.list_loadout:GetSelectedItem()
    if (not item) then
      return
    end
  end

  local points = item.points

  if (points > self.points_left) then
    return
  end

  self.points_used = self.points_used + points
  self.points_left = self.points_left - points

  self.text_points_used:SetText(tostring(self.points_used))
  self.text_points_left:SetText(tostring(self.points_left))

  local _itm = set_list_text(item.idx, item.name, item.points, true)
  self.list_inv:AddExistingItem(_itm)
  self.list_loadout:RemoveItem(item)

  self:ClearItem()
end

function faction_ui:OnSelectDifficulty()
  self.selected_difficulty = self.table_difficulty[self.list_difficulty:CurrentID()]
  self.selected_money = self.table_difficulty_money[self.selected_difficulty]

  self:UpdateMoney()
end

function faction_ui:OnSelectSector()
  self.selected_sector = self.table_sectors[self.list_sectors:CurrentID()]

  ini_map = ini_file(string.format("plugins\\new_game_start_locations\\%s.ltx", self.selected_sector))

  self:LoadMap()
  self:UpdateCheckFactions()
end

function faction_ui:OnSelectRelations()
  self.selected_relations = self.table_relations[self.list_relations:CurrentID()]
end

function faction_ui:OnSelectLeader()
  self.selected_leader = self.table_leader[self.list_leader:CurrentID()]
end

function faction_ui:OnSelectHardcoreLives()
  self.selected_hardcore_lives = self.table_hardcore_lives[self.list_hardcore_lives:CurrentID()]
end

function faction_ui:OnSelectHardcoreRegen()
  self.selected_hardcore_regen = self.table_hardcore_regen[self.list_hardcore_regen:CurrentID()]
end

function faction_ui:OnSelectTimer()
  self.selected_timer = self.table_timer[self.list_timer:CurrentID()]
end

function faction_ui:OnMsgYes()
  axr_options.greatwar_config:w_value("greatwar_current_settings", "azazel", 0, false)
end

function faction_ui:OnCheckResetList()
  if (not self.access) then
    return
  end

  self:LoadLoadout()
end

--=======================================< Update visuals >=======================================--
function faction_ui:UpdateAll(rand, faction)
  self:LoadFaction(rand, faction)
  self:LoadIcon(rand)
  self:LoadMap(rand)

  self:UpdateMoney()
  self:UpdateDescr()

  self:LoadLoadout(rand)

  self:UpdateCheckFactions()
end

function faction_ui:UpdateFaction()
  self.box_faction:InitTexture("ui_new_game_flair_" .. self.selected_faction)
  self.box_faction:SetStretchTexture(true)
  self.box_faction:SetWndSize(vector2():set(self.box_faction:GetWidth(), self.box_faction:GetHeight()))
end

function faction_ui:UpdateIcon()
  self.box_icon:InitTexture(self.selected_icon)
  self.box_icon:SetStretchTexture(true)
  self.box_icon:SetWndSize(vector2():set(self.box_icon:GetWidth(), self.box_icon:GetHeight()))
end

function faction_ui:UpdateMap()
  local map = ini_map:r_string(self.selected_map, "level_name")

  self.box_map:InitTexture("ui_new_game_map_" .. map)
  self.box_map:SetStretchTexture(true)
  self.box_map:SetWndSize(vector2():set(self.box_map:GetWidth(), self.box_map:GetHeight()))
end

function faction_ui:UpdateMoney()
  self.text_money:SetText(tostring(self.selected_money) .. " RU")
end

function faction_ui:UpdateDescr()
  local faction = self.selected_faction

  -- Description and map
  local desc = "%c[0,250,250,250]" .. gs("st_mm_new_game_description")
  desc = desc .. "\\n%c[0,150,150,150]" .. gs("st_faction_" .. faction .. "_desc")

  self.text_descr:SetText(desc)
  self.text_descr:AdjustHeightToText()
  self.text_descr:SetWndSize(vector2():set(self.text_descr:GetWidth(), self.text_descr:GetHeight() + 10))
  self.scroll_desc:Clear()
  self.scroll_desc:AddWindow(self.text_descr, true)
  self.text_descr:SetAutoDelete(false)
end

function faction_ui:UpdateItem(item)
  if not (item) then
    return
  end

  -- description
  local desc = gs(ini:r_string_ex(item.name, "description"))

  self.text_item_descr:SetText(desc)
  self.text_item_descr:AdjustHeightToText()
  self.text_item_descr:SetWndSize(vector2():set(self.text_item_descr:GetWidth(), self.text_item_descr:GetHeight()))
  self.scroll_item_desc:Clear()
  self.scroll_item_desc:AddWindow(self.text_item_descr, true)
  self.text_item_descr:SetAutoDelete(false)

  -- name
  self.text_item_name:SetText("%c[0,150,150,50]Х %c[0,150,150,150]" .. gs(ini:r_string_ex(item.name, "inv_name") or ""))
  self.text_item_points:SetText(
    "%c[0,100,50,200]Х %c[0,150,150,150]" .. gs("st_mm_new_game_points") .. ": " .. tostring(item.points)
  )
  if (not item.allow) then
    self.text_item_points:SetText("%c[0,100,50,200]Х %c[0,150,150,150]" .. gs("st_mm_new_game_essential"))
  end

  -- Icon
  local ico = self:GetAxis_Item(item.name)
  self.box_item:InitTexture("ui\\ui_icon_equipment")
  self.box_item:SetTextureRect(Frect():set(ico.x1, ico.y1, ico.x2, ico.y2))
  self.box_item:SetStretchTexture(true)

  local pos = self.box_item_temp:GetWndPos()
  local _w = self.box_item_temp:GetWidth()
  local _h = self.box_item_temp:GetHeight()

  local ratio = ico.w / ico.h
  local h, w
  ico.w = ico.w * ico_size * ico_width
  ico.h = ico.h * ico_size

  local w_t, h_t = 0, 0
  local resize = false
  if (ico.w > _w) then -- if icon width is bigger than frame width
    w_t = ico.w - _w
    resize = true
  end
  if (ico.h > _h) then -- if icon height is bigger than frame height
    h_t = ico.h - _h
    resize = true
  end

  if resize then -- resize is required
    if (w_t >= h_t) then -- if icon width is the big number (or square), use it as a base for resizing
      w = _w
      h = w / ratio
    elseif (w_t < h_t) then -- if icon width is the big number, use it as a base for resizing
      h = _h
      w = h * ratio
    end
  else -- no resize
    w = ico.w
    h = ico.h
  end

  offset_x = (_w - w) / 2
  offset_y = (_h - h) / 2
  self.box_item:SetWndSize(vector2():set(w, h))
  self.box_item:SetWndPos(vector2():set(pos.x + offset_x, pos.y + offset_y))
end

function faction_ui:UpdateCheckFactions()
  for i = 1, #self.table_faction do
    local faction = self.table_faction[i]
    local check_cap_name = strformat("cap_check_faction_%s", faction)
    local check_name = strformat("check_faction_%s", faction)
    local color = "%c[0,150,150,50]Х %c[0,150,150,150]"
    local relation = relation_registry.community_relation(self.selected_faction, faction)

    if (relation >= 1000) then
      color = "%c[0,150,150,150]Х %c[0,50,175,50]"
    elseif (relation <= -1000) then
      color = "%c[0,150,150,150]Х %c[0,175,50,50]"
    else
      color = "%c[0,150,150,150]Х %c[0,175,175,50]"
    end

    self[check_cap_name]:TextControl():SetText(strformat("%s %s", color, gs("st_faction_" .. faction)))

    if string.find(self.selected_sector, "vs_") then
      local faction_sector = string.gsub(self.selected_sector, "vs_", "")

      if faction == self.selected_faction or faction == faction_sector then
        self.table_enabled_faction[faction] = true
        self[check_name]:SetCheck(true)
      else
        self.table_enabled_faction[faction] = false
        self[check_name]:SetCheck(false)
      end
    elseif self.selected_sector == "default" then
      self.table_enabled_faction[faction] = true
      self[check_name]:SetCheck(true)
    elseif self.selected_sector == "empty" then
      self.table_enabled_faction[faction] = false
      self[check_name]:SetCheck(false)
    end
  end
end

function faction_ui:ClearItem()
  self.text_item_name:SetText("")
  self.text_item_points:SetText("")
  self.scroll_item_desc:Clear()
  self.box_item:InitTexture("ui\\ui_icon_equipment")
  self.box_item:SetTextureRect(Frect():set(0, 0, 0, 0))
end

function faction_ui:GetAxis_Item(obj)
  local a = {}

  local inv_grid_x = ini:r_float_ex(obj, "inv_grid_x") or 0
  local inv_grid_y = ini:r_float_ex(obj, "inv_grid_y") or 0
  local inv_grid_width = ini:r_float_ex(obj, "inv_grid_width") or 0
  local inv_grid_height = ini:r_float_ex(obj, "inv_grid_height") or 0

  local x1 = inv_grid_x * 50
  local y1 = inv_grid_y * 50

  local w = inv_grid_width * 50
  local h = inv_grid_height * 50

  local x2 = x1 + w
  local y2 = y1 + h

  a.x1 = x1
  a.y1 = y1
  a.x2 = x2
  a.y2 = y2
  a.w = w
  a.h = h

  return a
end

function faction_ui:GetAxis_Icon(main, element, all_row, all_col, row, col)
  local _w = main:GetWidth()
  local _h = main:GetHeight()
  local _wi = element:GetWidth()
  local _hi = element:GetHeight()
  local off_x = (_w - _wi * all_col) / (all_col + 1)
  local off_y = (_h - _hi * all_row) / (all_row + 1)

  local x = (off_x * col) + (_wi * (col - 1))
  local y = (off_y * row) + (_hi * (row - 1))
  return x, y
end

--=======================================< Main Buttons >=======================================--
function faction_ui:OnQuit()
  if (not self.access) then
    return
  end

  self.owner:ShowDialog(true)
  self.owner:Show(true)
  if (self:IsShown()) then
    self:HideDialog()
  end
  self:Show(false)
end

function faction_ui:OnRandomize()
  if (not self.access) then
    return
  end

  -- Faction
  self.selected_faction = self.table_faction[math.random(#self.table_faction)]

  -- Name
  local subset
  if includes(self.selected_faction, "army", "ryskuspecnaz", "sby", "dolg") then
    subset = random_choice("private", "sergeant", "senior_sergeant", "lieutenant", "captain")
  else
    subset = random_choice("stalker", "bandit", "science")
  end
  local name_cnt = ini:r_float_ex("stalker_names_" .. subset, "name_cnt")
  local last_name_cnt = ini:r_float_ex("stalker_names_" .. subset, "last_name_cnt")
  local first_name = gs(strformat("name_%s_%s", subset, math.random(0, name_cnt - 1)))
  local last_name = gs(strformat("lname_%s_%s", subset, math.random(0, last_name_cnt - 1)))
  self.character_name:SetText(first_name .. " " .. last_name)

  ini_map = ini_file(string.format("plugins\\new_game_start_locations\\%s.ltx", self.selected_sector))

  -- Everything else
  self:UpdateAll(true, self.selected_faction)

  -- Difficulty and Economy
  self:LoadDifficulty(true)
  --self:LoadEconomy(true)
end

function faction_ui:OnKeyboard(dik, keyboard_action)
  if (not self.access) then
    return
  end

  local res = CUIScriptWnd.OnKeyboard(self, dik, keyboard_action)
  if (res == false) then
    if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
      if dik == DIK_keys.DIK_ESCAPE then
        self:OnQuit()
      elseif (dik == DIK_keys.DIK_Z) then
        self.selected_faction = "zombied"
        self:UpdateAll(false, self.selected_faction)
      elseif (dik == DIK_keys.DIK_S) then
      end
    end
  end
  return res
end

function faction_ui:OnStartGame()
  if (not self.access) then
    return
  end

  -- start game anyway if no config or axr_main script
  if not (axr_main and axr_main.config) then
    self.owner:StartGame()
    return
  end

  -- check name
  local character_name = self.character_name:GetText()
  if (character_name == "") then
    -- Require a name to be entered.
    return
  end

  -- check location
  if (self.selected_map == nil or self.selected_map == "" or self.list_map:CurrentID() <= 0) then
    self.selected_map = self.table_map[1]
  end

  -- save modes
  local hardcore_regen
  if (self.selected_hardcore_regen[1]) and (type(self.selected_hardcore_regen[1]) == "number") then
    hardcore_regen = self.selected_hardcore_regen[1]
  end

  local timer
  if (self.selected_timer[1]) and (type(self.selected_timer[1]) == "number") then
    timer = self.selected_timer[1]
  end

  -- prepare loadout
  local loadout_str
  for index = 0, self.list_inv:GetSize() - 1 do
    local item = self.list_inv:GetItemByIndex(index)
    if (not loadout_str) then
      loadout_str = item.name
    else
      loadout_str = loadout_str .. "," .. item.name
    end
  end

  axr_main.config:w_value(
    "character_creation",
    "new_game_hardcore_mode",
    self.ck_hardcore and self.ck_hardcore:GetCheck() and true or nil
  )
  axr_main.config:w_value(
    "character_creation",
    "new_game_hardcore_mode_lives",
    self.ck_hardcore and self.selected_hardcore_lives[1] or nil
  )
  axr_main.config:w_value(
    "character_creation",
    "new_game_hardcore_mode_regenerate",
    self.ck_hardcore and hardcore_regen or nil
  )
  axr_main.config:w_value(
    "character_creation",
    "new_game_survival_mode",
    self.ck_survival and self.ck_survival:GetCheck() and true or nil
  )
  axr_main.config:w_value(
    "character_creation",
    "new_game_azazel_mode",
    self.ck_azazel and self.ck_azazel:GetCheck() and true or nil
  )
  axr_main.config:w_value(
    "character_creation",
    "new_game_campfire_mode",
    self.ck_campfire and self.ck_campfire:GetCheck() and true or nil
  )
  axr_main.config:w_value(
    "character_creation",
    "new_game_conditions_mode",
    self.ck_conditions and self.ck_conditions:GetCheck() and true or nil
  )
  axr_main.config:w_value("character_creation", "new_game_timer_mode", timer or nil)

  axr_main.config:w_value("character_creation", "new_game_character_name", character_name:gsub(" ", "_"))
  axr_main.config:w_value("character_creation", "new_game_faction", self.selected_faction or nil)
  axr_main.config:w_value("character_creation", "new_game_icon", self.selected_icon or nil)
  axr_main.config:w_value("character_creation", "new_game_loadout", loadout_str or nil)
  axr_main.config:w_value("character_creation", "new_game_map", self.selected_map)
  axr_main.config:w_value("character_creation", "new_game_money", self.selected_money or nil)
  axr_main.config:w_value("character_creation", "new_game_sector", self.selected_sector)
  axr_main.config:w_value("character_creation", "new_game_relations", self.selected_relations)
  axr_main.config:w_value("character_creation", "new_game_leader", self.selected_leader)

  local tbl_enabled_faction = {}
  for faction, enabled in pairs(self.table_enabled_faction) do
    if enabled then
      axr_main.config:w_value("mm_options", "enable_respawn_" .. faction, true)
      table.insert(tbl_enabled_faction, faction)
    else
      axr_main.config:w_value("mm_options", "enable_respawn_" .. faction, false)
    end
  end

  axr_main.config:w_value("character_creation", "new_game_enabled_factions", table.concat(tbl_enabled_faction, ", "))

  axr_main.config:save() -- Store info in temp file
  self.owner:StartGame() -- Start the game
end

--=======================================< List Item  >=======================================--
class "set_list_text"(CUIListBoxItem)
function set_list_text:__init(idx, name, points, allow)
  super(idx, name, points, allow)

  self.idx = idx
  self.points = points
  self.allow = allow
  self.name = name
  self.string = name
  self.text = self:GetTextItem()
  self.text:SetWndRect(Frect():set(0, 0, 300, 22))
  self:SetTextColor(GetARGB(255, 245, 245, 245))
  self.text:SetFont(GetFontLetterica16Russian())
  self.text:SetWndSize(vector2():set(400, 22))
  self.text:SetEllipsis(true)
  self.text:SetText(gs(ini:r_string_ex(self.string, "inv_name") or ""))
end
